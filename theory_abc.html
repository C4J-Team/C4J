<html>
<head>
<title>C4J - Contracts for Java</title>
<link rel="stylesheet" type="text/css" href="all.css" />
<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="prettify/prettify.js"></script>
</head>

<body onload="prettyPrint()">
<table><tr><td id="navigation">
<img src="c4j.png" alt="C4J Logo"/>
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="ease-of-use.html">Ease of use</a></li>
<li><a href="powerful.html">Powerful</a></li>
<li><a href="six-principles.html">Six principles</a></li>
<li><a href="examples.html">Examples</a></li>
<li><a href="syntax.html">Syntax reference</a></li>
<li><a href="inheritance.html">Inheritance of contracts</a></li>
<li><a href="installation.html">Installation</a></li>
<li><a href="configuration.html">Configuration</a></li>
<li><a href="guidelines.html">Guidelines</a></li>
<li><a href="under-the-hood.html">Under the Hood</a></li>
<li><a href="theory.html">Theory</a></li>
<li><a href="faq.html">FAQ</a></li>
<li><a href="about.html">About</a></li>
</ul>
<ul>
<li><a href="https://github.com/C4J-Team/C4J/downloads" target="_blank">Download C4J 6.0.0</a></li>
<li><a href="http://c4j.sourceforge.net/" target="_blank">Download C4J 2.7.5</a></li>
</ul>
</td><td id="divider"></td><td id="content">
<div class="head">Analysis by Contract</div>
<P>
Analysis by Contract is a term coined by Richard Mitchell and Jim McKim in their book
<A href="http://www.amazon.com/Design-Contract-Example-Richard-Mitchell/dp/0201634600" 
target=_blank>Design by Contract by Example</A>.
<BR>
The idea is to define a new class on an abstract level from the viewpoint of an user
in order to explore the business context the customer has in mind.
This is done by implementing a test case from the user perspective,
a user acceptance test.
This idea is very close related to the concept of Test Driven Development (TDD).
Analysis therfore is not a several week or month phase known from classical forward engineering approaches
but a few minutes activity in a agile software engineering context.
The result of this iterative analysis activity looks like this (complete listing):
</P>
<PRE class="prettyprint">
package timeofday;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class TimeOfDayTest {
   private TimeOfDaySpec classUnderTest;

   private final int HOUR = 12;
   private final int MINUTE = 27;
   private final int SECOND = 54;

   @Before
   public void setUp() {
      classUnderTest = new TimeOfDay(HOUR, MINUTE, SECOND);
   }

   @Test
   public void getHourTest() {
      assertEquals(HOUR, classUnderTest.getHour());
   }

   @Test
   public void getMinuteTest() {
      assertEquals(MINUTE, classUnderTest.getMinute());
   }

   @Test
   public void getSecondTest() {
      assertEquals(SECOND, classUnderTest.getSecond());
   }

   @Test
   public void setHourTest() {
      classUnderTest.setHour(HOUR + 1);
      assertEquals(HOUR + 1, classUnderTest.getHour());
   }

   @Test
   public void setMinuteTest() {
      classUnderTest.setMinute(MINUTE + 1);
      assertEquals(MINUTE + 1, classUnderTest.getMinute());
   }

   @Test
   public void setSecondTest() {
      classUnderTest.setSecond(SECOND + 1);
      assertEquals(SECOND + 1, classUnderTest.getSecond());
   }

   @Test
   public void isBeforeHourTest() {
      TimeOfDaySpec other = new TimeOfDay(HOUR + 1, MINUTE, SECOND);
      assertTrue(classUnderTest.isBefore(other));
      assertFalse(other.isBefore(classUnderTest));
   }

   @Test
   public void isBeforeMinuteTest() {
      TimeOfDaySpec other = new TimeOfDay(HOUR, MINUTE + 1, SECOND);
      assertTrue(classUnderTest.isBefore(other));
      assertFalse(other.isBefore(classUnderTest));
   }

   @Test
   public void isBeforeSecondTest() {
      TimeOfDaySpec other = new TimeOfDay(HOUR, MINUTE, SECOND + 1);
      assertTrue(classUnderTest.isBefore(other));
      assertFalse(other.isBefore(classUnderTest));
   }

   @Test
   public void isBeforeSameTest() {
      TimeOfDaySpec other = classUnderTest;
      assertFalse(classUnderTest.isBefore(other));
      assertFalse(other.isBefore(classUnderTest));
   }

   @Test
   public void isBeforeEqualsTest() {
      TimeOfDaySpec other = new TimeOfDay(HOUR, MINUTE, SECOND);
      classUnderTest.isBefore(other);
      assertFalse(classUnderTest.isBefore(other));
      assertFalse(other.isBefore(classUnderTest));
   }
}
</PRE>

<P>
This test case is written test per test.
And test per test the addressed interface TimeOfDaySpec
- the <I>interface under test</I> - is growing.
Compiling the test case is possible by using the support of modern Java IDEs
to create an empty class TimeOfDay - the <I>class under test</I> -
which implements the <I>interface under test</I> TimeOfDaySpec
and is auto-completed each time the interface grows.
<BR>
Finally it looks like this (complete listing):
</P>
<PRE class="prettyprint">
package timeofday;

import de.vksi.c4j.Pure;

public interface TimeOfDaySpec {
   void setHour(int hour);

   void setMinute(int minute);

   void setSecond(int second);

   @Pure
   int getHour();

   @Pure
   int getMinute();

   @Pure
   int getSecond();

   @Pure
   boolean isBefore(TimeOfDaySpec other);
}
</PRE>

<P>
Please note that <I>command query separation</I> has already been accomplished to this interface,
following the
<A href="six-principles.html">six principles</A>.
Methods annotated as pure are queries,
all other methods are commands.
Furthermore the queries have been separated into <I>basic</I> queries and <I>derived</I> queries,
which is important for the next activity,
<A href="theory_dbc.html">Design by Contract</A>.
</P>
</td></tr></table>
</body>
</html>